package f_oop2;

public class InheritanceBasic {
	
	public static void main(String[] args) {
		
		/*
		 1. 상속(~은 ~이다)
		   - 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		   - 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		   - 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써주기만 하면 된다.
		   
		     class Child extends Parent{
		     
		     }
		   
		   - 상속해주는 클래스를 '조상클래스'. 상속받는 클래스를 '자손클래스'라 한다.
		     : 조상클래스 - 부모클래스, 상위클래스, 기반클래스
		     : 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
		     
		   - 멤버만 상속한다. (멤버 : 멤버변수, 메서드)
		   - 자손클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
		     
		 2. 포함(~은 ~을 포함하고 있다)
		   - 상속이외에 클래스를 재사용하는 또 다른 방법
		   - 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
		   
		 3. 단일상속
		   - 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
		     class TVCR extends TV, VCR{	//다중상속 불가능
		     
		     }
		 	//불가능한 이유 : 상속해주는것중 중복되는것들중 어떤것을 불러오는지 알수 없는경우가 생긴다.
		 
		   - TV와 VCR의 동일한 명칭의 method가 있다면 어떤것을 호출할지 알수가 없다.
		   	 위의 메서드를 구분하기위해 VCR의 method의 명을 바꾼다면 이전에 사용중이던 VCR의 method호출을 전부 바꾸어야한다. 
		   	 결론: 더 번거로움..
		   	 
		   - 단일상속을 함으로써 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있다.
		   
		 4. Object클래스 (모든클래스의 조상)
		   - 모든 클래스 상속계층도 제일 위에 존재하는 조상 클래스이다.
		   - 다른 클래스로부터 상속받지 않는 클래스는 자동적으로 object클래스를 상속받는다.	 
		   	 컴파일 전
		     class Tv{
		     
		     }
		     컴파일 후
		     class Tv extends Object{
		     
		     }
		   - 모든클래스는 object클래스를 상속받게 된다. 
		   - toString(), equals() ... 따로 정의하지 않고 사용하는 것은 object클래스에 정의된 것들이기 때문이다. 
		 
		   
		  5. 오버라이딩 
		   - 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것
		   - 오버라이딩이 성립하기 위한 조건
		     : 자손클래스로부터 오버라이딩 하는 메서드는 조상클래스와 메서드명이 동일해야한다.
		       매개변수의 개수와 타입이 같아야한다.
		       리턴타입이 같아야한다.
		      
		       접근제어자를 조상클래스의 메서드보다 좁은 범위로 설정할 수 없다.
		       예외는 조상클래스의 메서드보다 많이 선언할 수 없다.  (exception에서 ...)
		       
		       인스턴스 메서드를 static메서드로 또는 그 반대로 변경 할 수 없다.
		    //메서드는 선언부와 구현부로 구성되어있다.
		    //메서드의 선언부는 같고 구현부가 바뀌는것
		  
		  
		  6. super.
		   - 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 서로 구별해야 하는 경우 사용한다.
		   - 조상멤버와 자신의 멤버를 구분하는데 사용된다는 점을 제외하고는 this.과 근본적으로 같다.
		   - 클래스메서드에서는 사용할 수 없고 인스턴스 메서드 안에서만 사용 가능하다.
		   
		  7. super() - 조상클래스의 생성자
		   - this()와 마찬가지로 super()역시 생성자 호출
		   - this()는 같은클래스의 다른 생성자를 호출
		   	 super()는 조상클래스의 생성자를 호출
		   - 생성자의 첫줄에는 조상클래스의 생성자를 호출한다.
		   	 자손클래스의 멤버가 조상클래스의 멤버를 사용 할 수 있으므로 조상의 멤버들이 먼저 초기화 되어야 한다.
		   	 
		  8. 제어자
		   - 클래스, 변수 또는 메서드의 선언부에 사용된다.
		   - 접근제어자와 그 외 제어자로 나누어진다.
		   - 접근제어자 : private, default, protected, public
		     그외제어자 : static, final, abstract, native, ...
		   - 접근제어자는 가장 왼쪽에 많이 둔다.
		   - static(클래스의, 공통적인)
		     : 멤버변수, 메서드, 초기화블럭		//클래스친구들에게 붙여줄수있다 클래스변수 클래스메서드 클래스초기화블럭
		     : 클래스변수
		       모든인스턴스에서 공통적으로 사용된다.
		       인스턴스를 생성하지 않고 사용할 수 있다.
		       클래스가 메모리에 로드될때 생성된다.
		       클래스명.변수명
		     : 클래스메서드
		       인스턴스를 생성하지 않고도 호출할 수 있다.
		       클래스명.메서드()
		   - final(마지막의, 변경할 수 없는)
		     : 변수에 사용시 변경할 수 없는 상수가 된다.
		     : 메서드에 사용시 오버라이드 할 수 없다.
		     : 클래스에 사용시 상속할 수없다. => 다른클래스의 조상이 될 수 없다. // 상속은 확장의 개념이므로 변경할 수 없는 개념인 final을 사용 할 수 없다.
		   - abstract(추상의, 미완성의)			//메서드와 클래스에서만 사용 가능하다. 메서드가 abstract면 클래스역시 abstract를 붙여줘야한다.
		     : 메서드에 사용시 선언부만 작성하고 구현부는 작성하지 않는 추상 메서드임을 알린다.
		     : 클래스에 사용시 추상메서드가 선언되어 있음을 알려준다.		//가지고있는 메서드들중에 추상메서드가 존재
		  
		  9. 접근제어자
		   - private : 같은 클래스 내에서만 접근 가능하다.
		   - default : 같은 패키지 내에서만 접근 가능하다.
		   - protected : 같은 패키지 + 다른패키지의 자손클래스가 접근 가능하다.
		   - public : 접근제한이 없다.
		   
		   - 클래스에는 public, default만 사용할 수 있다.
		   - 변수나 메서드에는 모두 사용가능하다.
		   
		  10. 캡슐화
		   - 접근제어자를 사용하는 이유
		    : 외부로부터 데이터를 보호하기 위해 
		    : 외부로부터 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서		    
		    
		    DTO(Data Table Object) 	-	?테이블 컬럼명 같이 맞춘거? 
		    VO(Variable Object)		-	?			  
		  
		  11. 생성자의 접근제어자
		   - 인스턴스의 생성을 제한할 수 있다.
		   - 생성자의 접근제어자를 private으로 지정
		    : 외부에서는 생성자에 접근할 수 없음으로 인스턴스를 생성할 수 없다.
		    : 다른클래스의 조상이 될 수 없다.
		    : 상속할 수 없는 클래스이므로 final을 추가하여 상속할 수 없는 클래스임을 알리는것이 좋다.
		    		   
		  	//다형성 형태가 다양하다 일단 상속관계가 되어있어야한다.
			//부모타입에 참조변수로 자손타입에 여러 인스턴스를 참조할수 있다.  			 			 
		  12. 다형성(polymorphism)
		   - 여러가지 형태를 가질 수 있는 능력
		   - 한 타입의 참조변수로 여러타입의 객체를 참조할 수 있다.
		   - 조상 타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		     반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다.
		     
		  13. 참조변수의 형변환
		   - 서로 상속관게에 있는 클래스에서만 형변환이 가능하다.
		   - 자손타입 -> 조상타입(up-casting) : 형변환 생략이 가능
		   - 조상타입 -> 자손타입(down-casting) : 형변환 생략이 불가능
		  
		  14. instanceof연산자
		   - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용  
		   - 연산결과가 true이면 참조변수가 검사한 타입으로 형변환이 가능하다.
		   - 클래스친구들은 참조변수의 타입에 영향을 받는다.
		   - 참조변수의 타입에 영향을 받지 않는것은 인스턴스 메서드 뿐이다.
		  
		  15. 매개변수의 다형성
		   - 참조변수의 다형적인 특징은 메서드의 매개변수에 적용된다.
		   
		  16. 여러가지 객체 배열(Vector)
		   - 배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
		     이를 Vector클래스를 이용하여 해결할 수 있다.
		   - 동적으로 크기가 관리되는 객체배열이라고 할 수 있다.
		   Vector()			: 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.
		   add()			: Vector의 객체를 추가한다.
		   remove() 		: Vector의 객체를 삭제한다.
		   isEmpty()		: Vector가 비어있는지 검사한다.
		   get(int index)	: 해당 index번째 위치의 객체를 반환한다.   
		   int size()		: 저장되어있는 객체의 개수를 반환한다.
		  
		 17. 추상클래스(abstract class)
		  - 미완성된 클래스 : 미완성된 메서드를 포함하고 있다는 의미
		    abstract class 클래스명{
		    
		    }
		  - 추상메서드
		  	: 메서드는 선언부와 구현부로 구성되어 있다.
		  	: 메서드의 선언부만 작성되고 구현부는 작성되지 않은 메서드를 추상메서드라 한다.
		  	
		  	abstract 리턴타입 메서드명(){
		  	
		  	}
		  	
		 18. 인터페이스(interface)
		  - 일종의 추상클래스 이지만 추상메서드와 상수만을 멤버로 가진다.
		  - 인터페이스의 작성
		    interface 인터페이스명{
		    	public static final 변수타입 변수명 = 값;
		    	public abstract 반환타입 메서드명(매개변수...);
		    			    	
		     }
		     : 모든 멤버변수는 public static final이어야 한다. 생략가능
		     : 모든 메서드는 public abstract이어야한다. 생략가능
		  		//생성자가 존재할수 없기 때문에 객체를 만들수없다.
		  - 인터페이스의 상속
		  //상속을 받으면 메서드 변수도 상속되기때문에 클래스를 상속받으면 인터페이스는 추상메서드와 상수만 갖기때문에 성립할수 없다.
		  //따라서 인터페이스는 인터페이스만 상속받을 수 있다.
		  //인터페이스는 다중상속이 가능하다. 상속받는 것이 어차피 구현부가 없고 상수값을 갖기때문에
		  
		     : 인터페이스는 인터페이스로부터만 상속받을 수 있다.
		          => 구현된 메서드를 받으면 인터페이스가 아니게 되기 때문이다. 
		     : 클래스와 달리 다중상속이 가능하다.
		     : 클래스와 달리 Object와 같은 최고 조상이 없다.
		  - 인터페이스의 구현(추상클래스와 비슷하다)
		     : 자체로는 인스턴스를 생성할 수 없다.
		     : 자신이 정의된 추상메서드와 몸통을 만들어주는 클래스를 작성해주어야한다.
		     : 클래스의 확장(extends), 인터페이스의 구현(implements)
		     : 인터페이스의 일부 메서드만 구현했다면 추상클래스가 되어야 한다.
		     : ~able(~을 할 수 있는)
		     
		   - 인터페이스의 다형성
		     : 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.  
		  
		   - 인터페이스의 장점
		     : 개발시간을 단축시킬 수 있다.
		     : 표준화가 가능하다.
		     : 서로관계없는 클래스간에 관계를 맺어 줄 수 있다.
		     : 독립적인 프로그래밍이 가능하다.
		     
		   - 인터페이스의 이해
		     : 클래스를 사용하는 쪽(user)과 클래스를 제공하는 쪽(provider)이 있다.
		     : 메서드를 사용하는 쪽에서는 사용되는 메서드의 선언부만 알면된다.
		       A - I - B 간접적 관계로 변환해준다.
		       
		 19. 내부클래스(inner class)
		   - 내부클래스란?
		     : 클래스내에 선언된 클래스이다.
		     : 서로 쉽게 접근 할 수 있고 불필요한 클래스를 감춤으로 복잡성을 줄일 수 있다.
		      
		   - 인스턴스 클래스(instance class)
		     : 외부클래스의 인스턴스멤버들과 관련된 작업을 한다.
		   - static 클래스(static class)
		     : 외부클래스의 클래스멤버들과 관련된 작업을 한다. 클래스메서드와 관련된 작업을 주로 한다.
		   - 지역클래스(local class)
		     : 외부클래스의 메서드나 초기화 블럭안에 선언된다.
		     : 선택영역 내에서만 사용할 수 있다.
		   - 익명클래스(anonymous class)
		     : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(1회용)		 
		 */
		
		
		
		/*
		 분석 - 설계 - 구현 - 테스트
		*/	
	
		
	}

}
